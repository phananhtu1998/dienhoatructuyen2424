// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: 0015_managebookinglist.sql

package database

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const addManageBookingList = `-- name: AddManageBookingList :execresult
INSERT INTO ` + "`" + `manage_booking_list` + "`" + ` (
    id,
    code,
    customer_id,
    time_booking,
    description,
    status,
    note,
    created_at,
    updated_at
)
VALUES(?,?,?,?,?,?,?,NOW(),NOW())
`

type AddManageBookingListParams struct {
	ID          string
	Code        string
	CustomerID  string
	TimeBooking time.Time
	Description string
	Status      string
	Note        string
}

func (q *Queries) AddManageBookingList(ctx context.Context, arg AddManageBookingListParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addManageBookingList,
		arg.ID,
		arg.Code,
		arg.CustomerID,
		arg.TimeBooking,
		arg.Description,
		arg.Status,
		arg.Note,
	)
}

const cancelBooking = `-- name: CancelBooking :exec
UPDATE ` + "`" + `manage_booking_list` + "`" + `
SET
    status = 'Đã hủy',
    note = ?,
    updated_at = NOW()
WHERE id = ?
`

type CancelBookingParams struct {
	Note string
	ID   string
}

func (q *Queries) CancelBooking(ctx context.Context, arg CancelBookingParams) error {
	_, err := q.db.ExecContext(ctx, cancelBooking, arg.Note, arg.ID)
	return err
}

const cancelBookingMultiple = `-- name: CancelBookingMultiple :exec
UPDATE ` + "`" + `manage_booking_list` + "`" + `
SET
    status = 'Đã hủy',
    note = ?,
    updated_at = NOW()
WHERE id IN (/*SLICE:ids*/?)
`

type CancelBookingMultipleParams struct {
	Note string
	Ids  []string
}

func (q *Queries) CancelBookingMultiple(ctx context.Context, arg CancelBookingMultipleParams) error {
	query := cancelBookingMultiple
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Note)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const checkCustomerRegister = `-- name: CheckCustomerRegister :one
SELECT COUNT(*) 
FROM ` + "`" + `manage_booking_list` + "`" + `  
WHERE customer_id = ? AND status = 'Chờ xác nhận'
`

func (q *Queries) CheckCustomerRegister(ctx context.Context, customerID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkCustomerRegister, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const confirmBooking = `-- name: ConfirmBooking :exec
UPDATE ` + "`" + `manage_booking_list` + "`" + `
SET
    status = 'Đã xác nhận',
    updated_at = NOW()
WHERE id = ?
`

func (q *Queries) ConfirmBooking(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, confirmBooking, id)
	return err
}

const countListManageBooking = `-- name: CountListManageBooking :one
SELECT 
    COUNT(*) 
FROM ` + "`" + `manage_booking_list` + "`" + ` mbl 
LEFT JOIN ` + "`" + `customer_info` + "`" + ` ci ON mbl.customer_id = ci.id 
LEFT JOIN ` + "`" + `vehicle` + "`" + ` v ON v.customer_id = mbl.customer_id 
LEFT JOIN ` + "`" + `parking_lot` + "`" + ` pl ON pl.id = v.parking_lot_id 
WHERE 
    ( ? IS NULL OR 
      mbl.code LIKE CONCAT('%', ?, '%') OR 
      ci.name LIKE CONCAT('%', ?, '%') OR 
      ci.email LIKE CONCAT('%', ?, '%') OR 
      v.number_plate LIKE CONCAT('%', ?, '%') 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          pl.id = ? 
    ) 
    AND ( ? = '0001-01-01 00:00:00 +0000 UTC' OR 
          mbl.created_at >= ? 
    ) 
    AND ( ? = '0001-01-01 00:00:00 +0000 UTC' OR 
          mbl.created_at <= ? 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          mbl.status = ? 
    )
`

type CountListManageBookingParams struct {
	Search       interface{}
	ParkingLotID string
	StartDate    time.Time
	EndDate      time.Time
	Status       string
}

func (q *Queries) CountListManageBooking(ctx context.Context, arg CountListManageBookingParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countListManageBooking,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.StartDate,
		arg.StartDate,
		arg.EndDate,
		arg.EndDate,
		arg.Status,
		arg.Status,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countListManageBookingNoDateFilter = `-- name: CountListManageBookingNoDateFilter :one
SELECT 
    COUNT(*) 
FROM ` + "`" + `manage_booking_list` + "`" + ` mbl 
LEFT JOIN ` + "`" + `customer_info` + "`" + ` ci ON mbl.customer_id = ci.id 
LEFT JOIN ` + "`" + `vehicle` + "`" + ` v ON v.customer_id = mbl.customer_id 
LEFT JOIN ` + "`" + `parking_lot` + "`" + ` pl ON pl.id = v.parking_lot_id 
WHERE 
    ( ? IS NULL OR 
      mbl.code LIKE CONCAT('%', ?, '%') OR 
      ci.name LIKE CONCAT('%', ?, '%') OR 
      ci.email LIKE CONCAT('%', ?, '%') OR 
      v.number_plate LIKE CONCAT('%', ?, '%') 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          pl.id = ? 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          mbl.status = ? 
    )
`

type CountListManageBookingNoDateFilterParams struct {
	Search       interface{}
	ParkingLotID string
	Status       string
}

func (q *Queries) CountListManageBookingNoDateFilter(ctx context.Context, arg CountListManageBookingNoDateFilterParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countListManageBookingNoDateFilter,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.Status,
		arg.Status,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countListManageBookingWithDateFilter = `-- name: CountListManageBookingWithDateFilter :one
SELECT 
    COUNT(*) 
FROM ` + "`" + `manage_booking_list` + "`" + ` mbl 
LEFT JOIN ` + "`" + `customer_info` + "`" + ` ci ON mbl.customer_id = ci.id 
LEFT JOIN ` + "`" + `vehicle` + "`" + ` v ON v.customer_id = mbl.customer_id 
LEFT JOIN ` + "`" + `parking_lot` + "`" + ` pl ON pl.id = v.parking_lot_id 
WHERE 
    ( ? IS NULL OR 
      mbl.code LIKE CONCAT('%', ?, '%') OR 
      ci.name LIKE CONCAT('%', ?, '%') OR 
      ci.email LIKE CONCAT('%', ?, '%') OR 
      v.number_plate LIKE CONCAT('%', ?, '%') 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          pl.id = ? 
    ) 
    AND ( 
          mbl.time_booking >= ? 
    ) 
    AND (
          mbl.time_booking <= ? 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          mbl.status = ? 
    )
`

type CountListManageBookingWithDateFilterParams struct {
	Search       interface{}
	ParkingLotID string
	StartDate    time.Time
	EndDate      time.Time
	Status       string
}

func (q *Queries) CountListManageBookingWithDateFilter(ctx context.Context, arg CountListManageBookingWithDateFilterParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countListManageBookingWithDateFilter,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.Status,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getInfoByCronjob = `-- name: GetInfoByCronjob :many
SELECT id, time_booking, status
FROM ` + "`" + `manage_booking_list` + "`" + `
WHERE is_deleted = false
`

type GetInfoByCronjobRow struct {
	ID          string
	TimeBooking time.Time
	Status      string
}

func (q *Queries) GetInfoByCronjob(ctx context.Context) ([]GetInfoByCronjobRow, error) {
	rows, err := q.db.QueryContext(ctx, getInfoByCronjob)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInfoByCronjobRow
	for rows.Next() {
		var i GetInfoByCronjobRow
		if err := rows.Scan(&i.ID, &i.TimeBooking, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListManageBooking = `-- name: GetListManageBooking :many
SELECT 
    mbl.id, 
    mbl.code, 
    mbl.time_booking, 
    mbl.status,
    ci.id as customer_id,
    ci.name AS customer_name,
    v.number_plate, 
    pl.name AS parking_name, 
    mbl.description 
FROM ` + "`" + `manage_booking_list` + "`" + ` mbl 
LEFT JOIN ` + "`" + `customer_info` + "`" + ` ci ON mbl.customer_id = ci.id 
LEFT JOIN ` + "`" + `vehicle` + "`" + ` v ON v.customer_id = mbl.customer_id 
LEFT JOIN ` + "`" + `parking_lot` + "`" + ` pl ON pl.id = v.parking_lot_id 
WHERE 
    ( ? IS NULL OR 
      mbl.code LIKE CONCAT('%', ?, '%') OR 
      ci.name LIKE CONCAT('%', ?, '%') OR 
      ci.email LIKE CONCAT('%', ?, '%') OR 
      v.number_plate LIKE CONCAT('%', ?, '%') 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          pl.id = ? 
    ) 
    AND ( ? = '0001-01-01 00:00:00 +0000 UTC' OR 
          mbl.created_at >= ? 
    ) 
    AND ( ? = '0001-01-01 00:00:00 +0000 UTC' OR 
          mbl.created_at <= ? 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          mbl.status = ? 
    ) 
LIMIT ? OFFSET ?
`

type GetListManageBookingParams struct {
	Search       interface{}
	ParkingLotID string
	StartDate    time.Time
	EndDate      time.Time
	Status       string
	Limit        int32
	Offset       int32
}

type GetListManageBookingRow struct {
	ID           string
	Code         string
	TimeBooking  time.Time
	Status       string
	CustomerID   sql.NullString
	CustomerName sql.NullString
	NumberPlate  sql.NullString
	ParkingName  sql.NullString
	Description  string
}

func (q *Queries) GetListManageBooking(ctx context.Context, arg GetListManageBookingParams) ([]GetListManageBookingRow, error) {
	rows, err := q.db.QueryContext(ctx, getListManageBooking,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.StartDate,
		arg.StartDate,
		arg.EndDate,
		arg.EndDate,
		arg.Status,
		arg.Status,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListManageBookingRow
	for rows.Next() {
		var i GetListManageBookingRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.TimeBooking,
			&i.Status,
			&i.CustomerID,
			&i.CustomerName,
			&i.NumberPlate,
			&i.ParkingName,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListManageBookingNoDateFilter = `-- name: GetListManageBookingNoDateFilter :many
SELECT 
    mbl.id, 
    mbl.code, 
    mbl.time_booking, 
    mbl.status,
    ci.id as customer_id,
    ci.name AS customer_name,
    v.number_plate, 
    pl.name AS parking_name, 
    mbl.description 
FROM ` + "`" + `manage_booking_list` + "`" + ` mbl 
LEFT JOIN ` + "`" + `customer_info` + "`" + ` ci ON mbl.customer_id = ci.id 
LEFT JOIN ` + "`" + `vehicle` + "`" + ` v ON v.customer_id = mbl.customer_id 
LEFT JOIN ` + "`" + `parking_lot` + "`" + ` pl ON pl.id = v.parking_lot_id 
WHERE 
    ( ? IS NULL OR 
      mbl.code LIKE CONCAT('%', ?, '%') OR 
      ci.name LIKE CONCAT('%', ?, '%') OR 
      ci.email LIKE CONCAT('%', ?, '%') OR 
      v.number_plate LIKE CONCAT('%', ?, '%') 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          pl.id = ? 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          mbl.status = ? 
    ) 
    ORDER BY mbl.created_at DESC
LIMIT ? OFFSET ?
`

type GetListManageBookingNoDateFilterParams struct {
	Search       interface{}
	ParkingLotID string
	Status       string
	Limit        int32
	Offset       int32
}

type GetListManageBookingNoDateFilterRow struct {
	ID           string
	Code         string
	TimeBooking  time.Time
	Status       string
	CustomerID   sql.NullString
	CustomerName sql.NullString
	NumberPlate  sql.NullString
	ParkingName  sql.NullString
	Description  string
}

func (q *Queries) GetListManageBookingNoDateFilter(ctx context.Context, arg GetListManageBookingNoDateFilterParams) ([]GetListManageBookingNoDateFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, getListManageBookingNoDateFilter,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.Status,
		arg.Status,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListManageBookingNoDateFilterRow
	for rows.Next() {
		var i GetListManageBookingNoDateFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.TimeBooking,
			&i.Status,
			&i.CustomerID,
			&i.CustomerName,
			&i.NumberPlate,
			&i.ParkingName,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListManageBookingWithDateFilter = `-- name: GetListManageBookingWithDateFilter :many
SELECT 
    mbl.id, 
    mbl.code, 
    mbl.time_booking, 
    mbl.status,
    ci.id as customer_id,
    ci.name AS customer_name,
    v.number_plate, 
    pl.name AS parking_name, 
    mbl.description 
FROM ` + "`" + `manage_booking_list` + "`" + ` mbl 
LEFT JOIN ` + "`" + `customer_info` + "`" + ` ci ON mbl.customer_id = ci.id 
LEFT JOIN ` + "`" + `vehicle` + "`" + ` v ON v.customer_id = mbl.customer_id 
LEFT JOIN ` + "`" + `parking_lot` + "`" + ` pl ON pl.id = v.parking_lot_id 
WHERE 
    ( ? IS NULL OR 
      mbl.code LIKE CONCAT('%', ?, '%') OR 
      ci.name LIKE CONCAT('%', ?, '%') OR 
      ci.email LIKE CONCAT('%', ?, '%') OR 
      v.number_plate LIKE CONCAT('%', ?, '%') 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          pl.id = ? 
    ) 
    AND (  
          mbl.time_booking >= ? 
    ) 
    AND ( 
        mbl.time_booking <= ? 
    ) 
    AND ( ? IS NULL OR 
          ? = '' OR 
          mbl.status = ? 
    ) 
    ORDER BY mbl.created_at DESC
LIMIT ? OFFSET ?
`

type GetListManageBookingWithDateFilterParams struct {
	Search       interface{}
	ParkingLotID string
	StartDate    time.Time
	EndDate      time.Time
	Status       string
	Limit        int32
	Offset       int32
}

type GetListManageBookingWithDateFilterRow struct {
	ID           string
	Code         string
	TimeBooking  time.Time
	Status       string
	CustomerID   sql.NullString
	CustomerName sql.NullString
	NumberPlate  sql.NullString
	ParkingName  sql.NullString
	Description  string
}

func (q *Queries) GetListManageBookingWithDateFilter(ctx context.Context, arg GetListManageBookingWithDateFilterParams) ([]GetListManageBookingWithDateFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, getListManageBookingWithDateFilter,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.ParkingLotID,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.Status,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListManageBookingWithDateFilterRow
	for rows.Next() {
		var i GetListManageBookingWithDateFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.TimeBooking,
			&i.Status,
			&i.CustomerID,
			&i.CustomerName,
			&i.NumberPlate,
			&i.ParkingName,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManageBookingById = `-- name: GetManageBookingById :one
SELECT mbl.id, mbl.code, mbl.time_booking, mbl.description, mbl.status,ci.name AS customer_name, ci.email, ci.mobile, v.number_plate,p.name AS payment_name, pl.name AS parking_name, mbl.note
FROM ` + "`" + `manage_booking_list` + "`" + ` mbl
LEFT JOIN ` + "`" + `customer_info` + "`" + ` ci ON mbl.customer_id = ci.id
LEFT JOIN ` + "`" + `vehicle` + "`" + ` v ON v.customer_id = mbl.customer_id
LEFT JOIN ` + "`" + `payment` + "`" + ` p ON p.id = ci.payment_id
LEFT JOIN ` + "`" + `parking_lot` + "`" + ` pl ON pl.id = v.parking_lot_id
WHERE mbl.id = ?
`

type GetManageBookingByIdRow struct {
	ID           string
	Code         string
	TimeBooking  time.Time
	Description  string
	Status       string
	CustomerName sql.NullString
	Email        sql.NullString
	Mobile       sql.NullString
	NumberPlate  sql.NullString
	PaymentName  sql.NullString
	ParkingName  sql.NullString
	Note         string
}

func (q *Queries) GetManageBookingById(ctx context.Context, id string) (GetManageBookingByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getManageBookingById, id)
	var i GetManageBookingByIdRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.TimeBooking,
		&i.Description,
		&i.Status,
		&i.CustomerName,
		&i.Email,
		&i.Mobile,
		&i.NumberPlate,
		&i.PaymentName,
		&i.ParkingName,
		&i.Note,
	)
	return i, err
}
