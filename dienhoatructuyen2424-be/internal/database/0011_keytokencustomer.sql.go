// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: 0011_keytokencustomer.sql

package database

import (
	"context"
)

const checkCustomerIdExists = `-- name: CheckCustomerIdExists :one
SELECT COUNT(id) AS total_count
FROM ` + "`" + `keytokencustomer` + "`" + `
WHERE customer_id = ?
`

func (q *Queries) CheckCustomerIdExists(ctx context.Context, customerID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkCustomerIdExists, customerID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countRefreshTokenByCustomer = `-- name: CountRefreshTokenByCustomer :one
SELECT COUNT(id) AS total_count
FROM ` + "`" + `keytokencustomer` + "`" + `
WHERE refresh_token = ?
`

func (q *Queries) CountRefreshTokenByCustomer(ctx context.Context, refreshToken string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRefreshTokenByCustomer, refreshToken)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const deleteKeyCustomer = `-- name: DeleteKeyCustomer :exec
DELETE FROM ` + "`" + `keytokencustomer` + "`" + ` WHERE customer_id = ?
`

func (q *Queries) DeleteKeyCustomer(ctx context.Context, customerID string) error {
	_, err := q.db.ExecContext(ctx, deleteKeyCustomer, customerID)
	return err
}

const foundRefreshTokenByCustomerId = `-- name: FoundRefreshTokenByCustomerId :one
SELECT COUNT(id) AS total_count
FROM ` + "`" + `keytokencustomer` + "`" + `
WHERE JSON_CONTAINS(refresh_tokens_used, ?, '$') 
AND customer_id = ?
`

type FoundRefreshTokenByCustomerIdParams struct {
	JSONCONTAINS string
	CustomerID   string
}

func (q *Queries) FoundRefreshTokenByCustomerId(ctx context.Context, arg FoundRefreshTokenByCustomerIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, foundRefreshTokenByCustomerId, arg.JSONCONTAINS, arg.CustomerID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const insertKeyCustomer = `-- name: InsertKeyCustomer :exec
INSERT INTO ` + "`" + `keytokencustomer` + "`" + ` (id, customer_id, refresh_token, refresh_tokens_used) 
VALUES (?, ?, ?, COALESCE(?, JSON_ARRAY()))
`

type InsertKeyCustomerParams struct {
	ID           string
	CustomerID   string
	RefreshToken string
	Column4      interface{}
}

func (q *Queries) InsertKeyCustomer(ctx context.Context, arg InsertKeyCustomerParams) error {
	_, err := q.db.ExecContext(ctx, insertKeyCustomer,
		arg.ID,
		arg.CustomerID,
		arg.RefreshToken,
		arg.Column4,
	)
	return err
}

const updateRefreshTokenCustomer = `-- name: UpdateRefreshTokenCustomer :exec
UPDATE ` + "`" + `keytokencustomer` + "`" + ` 
SET refresh_token = ?, update_at = CURRENT_TIMESTAMP
WHERE customer_id = ?
`

type UpdateRefreshTokenCustomerParams struct {
	RefreshToken string
	CustomerID   string
}

func (q *Queries) UpdateRefreshTokenCustomer(ctx context.Context, arg UpdateRefreshTokenCustomerParams) error {
	_, err := q.db.ExecContext(ctx, updateRefreshTokenCustomer, arg.RefreshToken, arg.CustomerID)
	return err
}

const updateRefreshTokenUsedByCustomerId = `-- name: UpdateRefreshTokenUsedByCustomerId :exec
UPDATE ` + "`" + `keytokencustomer` + "`" + `
SET refresh_token = ?, 
    refresh_tokens_used = CASE
        WHEN refresh_tokens_used IS NULL THEN JSON_ARRAY(?)
        ELSE JSON_ARRAY_APPEND(refresh_tokens_used, '$', ?)
    END,
    update_at = CURRENT_TIMESTAMP
WHERE customer_id = ?
`

type UpdateRefreshTokenUsedByCustomerIdParams struct {
	RefreshToken    string
	JSONARRAY       interface{}
	JSONARRAYAPPEND interface{}
	CustomerID      string
}

func (q *Queries) UpdateRefreshTokenUsedByCustomerId(ctx context.Context, arg UpdateRefreshTokenUsedByCustomerIdParams) error {
	_, err := q.db.ExecContext(ctx, updateRefreshTokenUsedByCustomerId,
		arg.RefreshToken,
		arg.JSONARRAY,
		arg.JSONARRAYAPPEND,
		arg.CustomerID,
	)
	return err
}
