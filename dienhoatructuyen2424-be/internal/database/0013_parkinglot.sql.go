// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: 0013_parkinglot.sql

package database

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const addParkingLot = `-- name: AddParkingLot :execresult
INSERT INTO ` + "`" + `parking_lot` + "`" + ` (
    id,
    code,
    name,
    area_id,
    number_of_floors,
    total_parking_positions,
    status,
    is_deleted,
    created_at,
    updated_at
)
VALUES(?,?,?,?,?,?,?,false,NOW(),NOW())
`

type AddParkingLotParams struct {
	ID                    string
	Code                  string
	Name                  string
	AreaID                string
	NumberOfFloors        int32
	TotalParkingPositions int32
	Status                int8
}

func (q *Queries) AddParkingLot(ctx context.Context, arg AddParkingLotParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addParkingLot,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.AreaID,
		arg.NumberOfFloors,
		arg.TotalParkingPositions,
		arg.Status,
	)
}

const checkCountParkingLotByIdArea = `-- name: CheckCountParkingLotByIdArea :one
SELECT count(id)
FROM ` + "`" + `parking_lot` + "`" + `
WHERE area_id IN (/*SLICE:ids*/?) AND is_deleted = false
`

func (q *Queries) CheckCountParkingLotByIdArea(ctx context.Context, ids []string) (int64, error) {
	query := checkCountParkingLotByIdArea
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const checkCountParkingSpot = `-- name: CheckCountParkingSpot :one
SELECT count(ps.id)
FROM ` + "`" + `parking_floor_management` + "`" + ` pfm
LEFT JOIN parking_spot ps ON pfm.id = ps.parking_floor_id
WHERE pfm.parking_lot_id IN (/*SLICE:ids*/?) AND ps.status = true
`

func (q *Queries) CheckCountParkingSpot(ctx context.Context, ids []string) (int64, error) {
	query := checkCountParkingSpot
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const checkTotalParkingPosion = `-- name: CheckTotalParkingPosion :one
SELECT pl.id, pl.code, pl.name, pl.total_parking_positions, pl.area_id, pl.number_of_floors   
FROM parking_lot pl 
JOIN parking_floor_management pfm ON pfm.parking_lot_id = pl.id
WHERE pl.is_deleted = false AND pfm.id = ?
`

type CheckTotalParkingPosionRow struct {
	ID                    string
	Code                  string
	Name                  string
	TotalParkingPositions int32
	AreaID                string
	NumberOfFloors        int32
}

func (q *Queries) CheckTotalParkingPosion(ctx context.Context, id string) (CheckTotalParkingPosionRow, error) {
	row := q.db.QueryRowContext(ctx, checkTotalParkingPosion, id)
	var i CheckTotalParkingPosionRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.TotalParkingPositions,
		&i.AreaID,
		&i.NumberOfFloors,
	)
	return i, err
}

const countParkingLotById = `-- name: CountParkingLotById :one
SELECT COUNT(id)
FROM ` + "`" + `parking_lot` + "`" + ` 
WHERE is_deleted = false AND id = ?
`

func (q *Queries) CountParkingLotById(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countParkingLotById, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteParkingLotByIds = `-- name: DeleteParkingLotByIds :exec
UPDATE ` + "`" + `parking_lot` + "`" + `
SET
    is_deleted = true,
    updated_at = NOW()
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteParkingLotByIds(ctx context.Context, ids []string) error {
	query := deleteParkingLotByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const getCountListParkingLot = `-- name: GetCountListParkingLot :one
SELECT count(pl.id)
FROM parking_lot pl
LEFT JOIN area a ON a.id = pl.area_id
WHERE pl.is_deleted = false AND a.is_deleted = false
  AND (
      ? IS NULL OR
      pl.code LIKE CONCAT('%', ?, '%') OR 
      pl.name LIKE CONCAT('%', ?, '%') OR
      a.name LIKE CONCAT('%', ?, '%') OR
      pl.total_parking_positions LIKE CONCAT('%', ?, '%')
  )
  AND (
      ? IS NULL OR ? = '' OR pl.area_id = ?
  )
  AND (
      ? IS NULL OR ? = '' OR pl.status = ?
  )
`

type GetCountListParkingLotParams struct {
	Search interface{}
	AreaID string
	Status int8
}

func (q *Queries) GetCountListParkingLot(ctx context.Context, arg GetCountListParkingLotParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountListParkingLot,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.AreaID,
		arg.AreaID,
		arg.AreaID,
		arg.Status,
		arg.Status,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getListParkingLot = `-- name: GetListParkingLot :many
SELECT 
    pl.id,
    pl.code,
    pl.name,
    a.name AS area_name,
    pl.total_parking_positions  AS total_parking_positions,
    pl.number_of_floors,
    pl.status
FROM parking_lot pl
LEFT JOIN area a ON a.id = pl.area_id
WHERE pl.is_deleted = false AND a.is_deleted = false
  AND (
      ? IS NULL OR
      pl.code LIKE CONCAT('%', ?, '%') OR 
      pl.name LIKE CONCAT('%', ?, '%') OR
      a.name LIKE CONCAT('%', ?, '%') OR
      pl.total_parking_positions LIKE CONCAT('%', ?, '%')
  )
  AND (
      ? IS NULL OR ? = '' OR pl.area_id = ?
  )
  AND (
      ? IS NULL OR ? = '' OR pl.status = ?
  )
GROUP BY pl.id, pl.code, pl.name, a.name, pl.number_of_floors, pl.status
LIMIT ? OFFSET ?
`

type GetListParkingLotParams struct {
	Search interface{}
	AreaID string
	Status int8
	Limit  int32
	Offset int32
}

type GetListParkingLotRow struct {
	ID                    string
	Code                  string
	Name                  string
	AreaName              sql.NullString
	TotalParkingPositions int32
	NumberOfFloors        int32
	Status                int8
}

func (q *Queries) GetListParkingLot(ctx context.Context, arg GetListParkingLotParams) ([]GetListParkingLotRow, error) {
	rows, err := q.db.QueryContext(ctx, getListParkingLot,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.AreaID,
		arg.AreaID,
		arg.AreaID,
		arg.Status,
		arg.Status,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListParkingLotRow
	for rows.Next() {
		var i GetListParkingLotRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.AreaName,
			&i.TotalParkingPositions,
			&i.NumberOfFloors,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListParkingLotForSearch = `-- name: GetListParkingLotForSearch :many
SELECT id, name   
FROM parking_lot 
WHERE is_deleted = false ORDER BY created_at DESC
`

type GetListParkingLotForSearchRow struct {
	ID   string
	Name string
}

func (q *Queries) GetListParkingLotForSearch(ctx context.Context) ([]GetListParkingLotForSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, getListParkingLotForSearch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListParkingLotForSearchRow
	for rows.Next() {
		var i GetListParkingLotForSearchRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParkingLotById = `-- name: GetParkingLotById :one
SELECT id,code,name,status,area_id,number_of_floors,total_parking_positions,created_at
FROM ` + "`" + `parking_lot` + "`" + ` 
WHERE is_deleted = false AND id = ?
`

type GetParkingLotByIdRow struct {
	ID                    string
	Code                  string
	Name                  string
	Status                int8
	AreaID                string
	NumberOfFloors        int32
	TotalParkingPositions int32
	CreatedAt             time.Time
}

func (q *Queries) GetParkingLotById(ctx context.Context, id string) (GetParkingLotByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getParkingLotById, id)
	var i GetParkingLotByIdRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Status,
		&i.AreaID,
		&i.NumberOfFloors,
		&i.TotalParkingPositions,
		&i.CreatedAt,
	)
	return i, err
}

const updateParkingLotById = `-- name: UpdateParkingLotById :exec
UPDATE ` + "`" + `parking_lot` + "`" + ` 
SET
    name = ?,
    status = ?,
    updated_at = NOW()
WHERE id = ?
`

type UpdateParkingLotByIdParams struct {
	Name   string
	Status int8
	ID     string
}

func (q *Queries) UpdateParkingLotById(ctx context.Context, arg UpdateParkingLotByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateParkingLotById, arg.Name, arg.Status, arg.ID)
	return err
}
