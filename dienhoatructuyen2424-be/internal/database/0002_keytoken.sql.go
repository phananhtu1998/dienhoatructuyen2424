// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: 0002_keytoken.sql

package database

import (
	"context"
)

const countByAccount = `-- name: CountByAccount :one
SELECT COUNT(*) AS total_count
FROM keytoken
WHERE account_id = ?
`

func (q *Queries) CountByAccount(ctx context.Context, accountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countByAccount, accountID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countByTokenAndAccount = `-- name: CountByTokenAndAccount :one
SELECT COUNT(*) AS total_count
FROM keytoken
WHERE JSON_CONTAINS(refresh_tokens_used, ?, '$') 
AND account_id = ?
`

type CountByTokenAndAccountParams struct {
	JSONCONTAINS string
	AccountID    string
}

func (q *Queries) CountByTokenAndAccount(ctx context.Context, arg CountByTokenAndAccountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countByTokenAndAccount, arg.JSONCONTAINS, arg.AccountID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countRefreshTokenByAccount = `-- name: CountRefreshTokenByAccount :one
SELECT COUNT(*) AS total_count
FROM keytoken
WHERE refresh_token = ?
`

func (q *Queries) CountRefreshTokenByAccount(ctx context.Context, refreshToken string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRefreshTokenByAccount, refreshToken)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const deleteKey = `-- name: DeleteKey :exec
DELETE FROM ` + "`" + `keytoken` + "`" + ` WHERE account_id = ?
`

func (q *Queries) DeleteKey(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, deleteKey, accountID)
	return err
}

const insertKey = `-- name: InsertKey :exec
INSERT INTO ` + "`" + `keytoken` + "`" + ` (id, account_id, refresh_token, refresh_tokens_used) 
VALUES (?, ?, ?, COALESCE(?, JSON_ARRAY()))
`

type InsertKeyParams struct {
	ID           string
	AccountID    string
	RefreshToken string
	Column4      interface{}
}

func (q *Queries) InsertKey(ctx context.Context, arg InsertKeyParams) error {
	_, err := q.db.ExecContext(ctx, insertKey,
		arg.ID,
		arg.AccountID,
		arg.RefreshToken,
		arg.Column4,
	)
	return err
}

const updateRefreshToken = `-- name: UpdateRefreshToken :exec

UPDATE ` + "`" + `keytoken` + "`" + ` 
SET refresh_token = ?, update_at = CURRENT_TIMESTAMP
WHERE account_id = ?
`

type UpdateRefreshTokenParams struct {
	RefreshToken string
	AccountID    string
}

// Nếu NULL, đặt giá trị mặc định là JSON_ARRAY()
func (q *Queries) UpdateRefreshToken(ctx context.Context, arg UpdateRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateRefreshToken, arg.RefreshToken, arg.AccountID)
	return err
}

const updateRefreshTokenAndUsedTokens = `-- name: UpdateRefreshTokenAndUsedTokens :exec
UPDATE ` + "`" + `keytoken` + "`" + `
SET refresh_token = ?, 
    refresh_tokens_used = CASE
        WHEN refresh_tokens_used IS NULL THEN JSON_ARRAY(?)
        ELSE JSON_ARRAY_APPEND(refresh_tokens_used, '$', ?)
    END,
    update_at = CURRENT_TIMESTAMP
WHERE account_id = ?
`

type UpdateRefreshTokenAndUsedTokensParams struct {
	RefreshToken    string
	JSONARRAY       interface{}
	JSONARRAYAPPEND interface{}
	AccountID       string
}

func (q *Queries) UpdateRefreshTokenAndUsedTokens(ctx context.Context, arg UpdateRefreshTokenAndUsedTokensParams) error {
	_, err := q.db.ExecContext(ctx, updateRefreshTokenAndUsedTokens,
		arg.RefreshToken,
		arg.JSONARRAY,
		arg.JSONARRAYAPPEND,
		arg.AccountID,
	)
	return err
}
